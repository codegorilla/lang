// Test file


var x = 10;

def myfun (x) = x + 1;

print myfun(5);

class Cow extends Animal {
}


do {
  x = 50;
} while (x < 10);

print x;


var y = 10;

while (y < 10) {
  y = 50;
};

print y;





// var s = [1, 2.1, 3, 4, 5];

//var s = [2, 3];
//print s;

//var t = 1;
//print t;

//var t0 = "hello";
//var t1 = " world!";

//print t0 + t1;

//var a = 1;

//var b = 81;
//print b;


//def celsiusToFarenheit (x) = x * 1.8 + 32;

//val x1 = celsiusToFarenheit(0);
//print x1;

//val x2 = celsiusToFarenheit(100);
//print x2;

//{
//  x * 1.8 + 32;
//}

//def add2 (x, y) = {
//  x + y;
//};

//val k = add2(300, 65);
//print k;

// lambda function
// var fn = lambda (x) => x + 1;;

// var g = 1;

//{
//  var c = 100;
//  {
//    10 + 2;
//    b = 10;
//    print b + 400;
//    14;
//  };
//  print b;
//};


//var b = "world!";

//var c = a + b;
//print c;


//var y = 5;
//var z = 10;

//var x = y + z;
//print x;

//var b = 4.1e-2;
//print b;

//var c = 4e-2;
//print c;

//var x = 0;
//print x;

//var t = 100;

// var a = if (x == 0) { 100; } else { 200; };
//var a = if (x == 1)
//  t
//else
//  t + 1
//;

//print a;


//if (x == 1) {
//  x = 10;
//} else {
//  x = 20;
//};

//print x;



// Need to figure out block expressions before doing if expressions
//var t = {
//  var x = 2;
//  print x;
//  10;
//};

//var a = null;
//print a;

//print t;

// statement form
//if (x == 0)
//  return 4;
//else
//  return 10;

//if (expr) stmt [else stmt]

// expression form
//if (x == 0) 4 else 10;

//if (expr) forceExpr [;] [else forceExpr] ;

//forceExpr:
//  expression |
//  statement

//if (expr) expr => if (expr) expr else ();

//if (expr) stmt => if (expr) { stmt } else ();

//def f (x) = if (x == 0) false else true;


//def myfun () =
//  if (x == 0) 4 else 10

//def myfun () =
//  if (expr) (stmt | expr [;]) else (stmt | expr) ;

//  if (expr) stmt else blockExpr ;

//  if (x == 0) true

//impliedBlock ::=
//  statementMinus

//if (x == 0) 1 else 2;

//if (x == 0)
//  1;
//else
//  2;

//if (x == 0) {
//  print 1;
//}
//else {
//  print 2;
//};



//if (x == 0) 1 else { print 2; };

//val z = if(x < 10, 0, 1);

//val z = if(x < 10, { 0; }, { 1; });


//if (x == 0)
//  1;
//else
//  print 2;
//;

//val t = if (x == 0)
//  1
//else
//  2;

//if (x == 0)
//  1;
//else {
//  print 2;
//}
//;


//var t = 120;
//print t;

//while (x < 12) {
//  print x;
//  x = x + 1;
//  var t = 240;
//  print t;
//}

//print t;

//var a = true;
//var b = !true;
//var c = false;
//var d = !false;

//var x = (7 & 5) << 2;
//var y = 12 + 4.5 / 1.25;
//var z = true != false;

// var a = null;

// Test if statement

//if (x < 4)
//  var s = x + 2;
//else if (x > 10)
//  var t = x + 4;
//else
//  var u = x + 6;

// if (a < 10 && b > 5)
//   var s = x + 2;
// else if (t > 10)
//  var t = x + 41;
//else
//  var u = x+1;

// var y = a < 10 || b > 5;

//var x = 5 | 100 & 12 ^ 4;
//4 + 2;
//var y = 1 + 10 / 4;
//return 5;

// var s = x == 4;
// var t = x != 4;

// var x = 1 | true;
//var y = 0 & false;

//var x = (1 + 5) * 4;

// Test unit
//var a = ();

//return ();

// Test 1-tuple
//var b = (2,);

// Test n-tuple
// var c = (2, 4);

// Test imaginary
// var z = 3 + 4j;
// 1 + 2j;
// 15j + 1;

// Test function calls
//var a = foo(x, 4);

// Test array access
//var b = bar[i+5];

// Test object access
//var c = foo.bar;

// Test function call on function object returned from another function call
//var d = foo(x)(y, z);

// Test function call on function object returned from collection
//var e = bar[x](y, z);

// Test function call on function object returned from object
//var f = baz.x(y,z);

// Test unit vs. expressions vs. tuples
// var a = ();
// var b = (s);
// var c = (s,);
// var d = (s, t);
// var e = (s, t,);

// Test arrays
// var a = [];
// var b = [s];
// var c = [s,];
// var d = [s, t];
// var e = [s, t,];

// (x) = expression
// (x,) = tuple
// (x, y) = tuple
// (x) -> x + 1 = lambda function
// (x,) -> x + 1 = lambda function?
// (x, y) -> x + y = lambda function

// For now support no parenthesis for arity-0 only
// Later on might support it with arity-N using '@' notation
// t.foo(x, 4); // seen as function call
// t.foo @(x, 4); // method call foo with tuple argument (using special lexer trick)
// t.foo[x, 4]; // seen as array access
// t.foo @[x, 4]; // method call foo with array argument (using special lexer trick)
// t.foo @{ 'x' => 1, 'y' => z }

// list.each { (x) -> x + 1 }

// var t = myfun { 'apple' => 1, 'banana' => 3 };

//val A = new Matrix([1, 2, 3]);
//val B = mat [1, 2, 3];

// Test alternative function/method calls
// foo(x) --> foo.apply(x)
// foo x --> foo (x) --> foo.apply(x)
// foo --> might only work for methods because this is the function object itself

// Test array access
// foo[x]

// Test object access
// foo.x

//fun strlen (x) = 1;

//while (x)
// var x = 1;

